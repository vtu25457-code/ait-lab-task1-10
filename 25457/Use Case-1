import heapq

def heuristic(a, b):
    # Manhattan distance heuristic
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def a_star_search(start, goal, graph):
    open_list = []
    heapq.heappush(open_list, (0 + heuristic(start, goal), 0, start, [start]))
    visited = set()

    while open_list:
        f, g, current, path = heapq.heappop(open_list)

        if current == goal:
            return path, g

        if current in visited:
            continue
        visited.add(current)

        for neighbor, cost in graph.get(current, []):
            if neighbor not in visited:
                new_g = g + cost
                new_f = new_g + heuristic(neighbor, goal)
                heapq.heappush(open_list, (new_f, new_g, neighbor, path + [neighbor]))

    return None, float("inf")

# Example Map (Graph)
graph = {
    'A': [('B', 1), ('C', 3)],
    'B': [('D', 1), ('E', 5)],
    'C': [('F', 2)],
    'D': [('G', 2)],
    'E': [('G', 1)],
    'F': [('G', 4)],
    'G': []
}

# Node positions for heuristic (x, y)
positions = {
    'A': (0, 0),
    'B': (1, 0),
    'C': (0, 1),
    'D': (2, 0),
    'E': (3, 0),
    'F': (0, 2),
    'G': (3, 1)
}

# Wrapper for heuristic with coordinates
def heuristic(a, b):
    ax, ay = positions[a]
    bx, by = positions[b]
    return abs(ax - bx) + abs(ay - by)

# Run A* Search
start, goal = 'A', 'G'
path, cost = a_star_search(start, goal, graph)

print("Shortest Path:", path)
print("Total Cost:", cost)
